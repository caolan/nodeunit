{
  "name": "spawn-wrap",
  "version": "1.0.1",
  "description": "Wrap all spawned Node.js child processes by adding environs and arguments ahead of the main JavaScript file argument.",
  "main": "index.js",
  "dependencies": {
    "foreground-child": "^1.2.0",
    "mkdirp": "^0.5.0",
    "os-homedir": "^1.0.1",
    "rimraf": "^2.3.3",
    "signal-exit": "^2.0.0"
  },
  "scripts": {
    "test": "tap test/*.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/isaacs/spawn-wrap.git"
  },
  "author": {
    "name": "Isaac Z. Schlueter",
    "email": "i@izs.me",
    "url": "http://blog.izs.me/"
  },
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/isaacs/spawn-wrap/issues"
  },
  "homepage": "https://github.com/isaacs/spawn-wrap#readme",
  "devDependencies": {
    "tap": "^1.1.0",
    "win-spawn": "^2.0.0"
  },
  "gitHead": "aa0c61536567be2bacb91cba5a786c9044ae65ea",
  "readme": "# spawn-wrap\n\nWrap all spawned Node.js child processes by adding environs and\narguments ahead of the main JavaScript file argument.\n\nAny child processes launched by that child process will also be\nwrapped in a similar fashion.\n\nThis is a bit of a brutal hack, designed primarily to support code\ncoverage reporting in cases where tests or the system under test are\nloaded via child processes rather than via `require()`.\n\nIt can also be handy if you want to run your own mock executable\ninstead of some other thing when child procs call into it.\n\n## USAGE\n\n```javascript\nvar wrap = require('spawn-wrap')\n\n// wrap(wrapperArgs, environs)\nvar unwrap = wrap(['/path/to/my/main.js', 'foo=bar'], { FOO: 1 })\n\n// later to undo the wrapping, you can call the returned function\nunwrap()\n```\n\nIn this example, the `/path/to/my/main.js` file will be used as the\n\"main\" module, whenever any Node or io.js child process is started,\nwhether via a call to `spawn` or `exec`, whether node is invoked\ndirectly as the command or as the result of a shebang `#!` lookup.\n\nIn `/path/to/my/main.js`, you can do whatever instrumentation or\nenvironment manipulation you like.  When you're done, and ready to run\nthe \"real\" main.js file (ie, the one that was spawned in the first\nplace), you can do this:\n\n```javascript\n// /path/to/my/main.js\n// process.argv[1] === 'foo=bar'\n// and process.env.FOO === '1'\n\n// my wrapping manipulations\nsetupInstrumentationOrCoverageOrWhatever()\nprocess.on('exit', function (code) {\n  storeCoverageInfoSynchronously()\n})\n\n// now run the instrumented and covered or whatever codes\nrequire('spawn-wrap').runMain()\n```\n\n## CAVEATS\n\nThe initial wrap call uses synchronous I/O.  Probably you should not\nbe using this script in any production environments anyway.\n\nAlso, this will slow down child process execution by a lot, since\nwe're adding a few layers of indirection.\n\nI would not be very surprised to find out that it works on Windows.\nNo way to tell for certain, though.\n",
  "readmeFilename": "README.md",
  "_id": "spawn-wrap@1.0.1",
  "_shasum": "ddc6d4a8af9838575b974796c5b0c0b38492d1c2",
  "_from": "git+https://github.com/bcoe/spawn-wrap.git#windows",
  "_resolved": "git+https://github.com/bcoe/spawn-wrap.git#aa0c61536567be2bacb91cba5a786c9044ae65ea"
}
